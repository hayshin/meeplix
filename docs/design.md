UI/UX и MVP для Narrari
1. Главная страница (Landing Page)

    Элементы: Поле для ввода имени игрока (никнейма) и кнопка "Создать игру".
    Логика: При вводе ника и нажатии кнопки, фронтенд отправляет запрос на бэкенд для создания новой игровой сессии. Никнейм сохраняется в LocalStorage для удобства пользователя.

2. Создание и присоединение к игре

    Процесс:
        Бэкенд создает новую WebSocket-комнату с уникальным UUID (например, /game/{uuid}).
        Фронтенд перенаправляет пользователя на URL этой комнаты (например, yourgame.com/game/{uuid}).
        Приглашение: Пользователь может скопировать и поделиться этим URL с друзьями.
        Присоединение: Когда новый пользователь переходит по ссылке, фронтенд проверяет LocalStorage на наличие ника. Если его нет, появляется всплывающее окно для выбора ника. После ввода ника, фронтенд устанавливает WebSocket-соединение с бэкендом, присоединяясь к соответствующей комнате.
    Идентификация: Каждый игрок в сессии идентифицируется по своему никнейму и уникальному ID сессии (который бэкенд присваивает при подключении).

3. Игровой экран (Game Session UI)
Общие элементы:

    Список игроков (слева сверху):
        Отображает никнеймы всех подключенных игроков.
        Чётко помечает, кто является текущим ведущим (рассказчиком).
        Порядок ведущего определяется по порядку подключения к игре.
    Статусная строка (сверху экрана): Динамически обновляется, информируя игроков о текущем этапе игры (например, "Ожидание выбора ведущего", "Придумайте ассоциацию", "Ожидание других игроков").
    Карты игрока (снизу): Отображаются в виде "руки" карт, как в покере/карточной игре.

Роли и взаимодействия:

    Для Ведущего (Рассказчика):
        Уведомление: "Вам необходимо выбрать карту и ввести для неё ассоциацию/связь."
        Действие: Выбирает одну из своих карт и вводит текстовую ассоциацию.
    Для Других Игроков:
        Уведомление: "Сейчас {никнейм_ведущего} ведущий. Пожалуйста, подождите, пока он выберет ассоциацию и карту."
    После выбора Ведущим:
        Уведомление (всем): "Ассоциация: '{ассоциация_ведущего}'" и "Выберите карту, похожую на эту ассоциацию, чтобы перепутать других игроков."
        Действие: Каждый игрок выбирает одну из своих карт, максимально подходящую под объявленную ассоциацию.
    Ожидание других игроков:
        Статусная строка: "Ожидание выбора карт от других игроков..."

4. Фаза голосования

    Отображение карт: После того как все игроки сделали свой выбор, все выбранные карты (включая карту ведущего) появляются по центру экрана.
        Компонент "Карта": При нажатии на карту она увеличивается для лучшего рассмотрения.
        Выбор для голосования: Для голосования можно использовать:
            Двойной клик/тап по карте.
            Отдельная кнопка "Проголосовать" под увеличенной картой, или при наведении/нажатии на маленькую карту.
            Перетаскивание (Drag & Drop) карты на специальную область "Ваш выбор" (более сложно для MVP).
            Предложение: Двойной клик/тап — это интуитивно и эффективно для MVP. Либо при одинарном клике карта увеличивается, и внизу увеличенной карты появляется кнопка "Выбрать эту карту".
    Уведомление: "Выберите карту, по которой вы предполагаете, что это карта ведущего."

5. Подсчёт очков и завершение раунда

    Результаты: На каждой карте всплывает аватарка пользователя (случайный цвет + первая буква никнейма), проголосовавшего за эту карту. Рядом с картой ведущего и картами, за которые проголосовали, появляются их аватарки.
    Таблица очков: В конце раунда появляется таблица с:
        Текущим общим количеством очков для каждого игрока.
        Очками, полученными в текущем раунде, отображаемыми как "+{число}" (зелёный цвет).
    Конец игры: Игра продолжается до тех пор, пока кто-то не наберёт, например, 20 очков. В будущем будут добавлены настройки.

Детали реализации Бэкенда (ElysiaJS + Drizzle-ORM)
1. Архитектура файлов и модулей

    Разделите бэкенд на логические модули: auth, users, games, cards, websocket.
    Используйте Drizzle-ORM для определения схем базы данных и выполнения запросов.

2. Управление игровыми сессиями

    Модель данных для GameSession (Drizzle Schema):
    TypeScript

    // src/db/schema.ts
    import { pgTable, uuid, text, integer, jsonb, timestamp } from 'drizzle-orm/pg-core';

    export const gameSessions = pgTable('game_sessions', {
        id: uuid('id').defaultRandom().primaryKey(),
        uuid: text('uuid').unique().notNull(), // Для URL-а
        status: text('status').default('waiting').notNull(), // 'waiting', 'playing', 'finished'
        currentRound: integer('current_round').default(1).notNull(),
        leaderPlayerId: text('leader_player_id'), // ID текущего ведущего игрока
        players: jsonb('players').$type<{ id: string; nickname: string; score: number; order: number; }[]>(), // Массив игроков с их данными
        deck: jsonb('deck').$type<string[]>(), // Массив URL/ID карт, доступных в игре (предзагруженные)
        currentAssociation: text('current_association'),
        roundData: jsonb('round_data').$type<{ leaderCardId: string; playerSelections: Record<string, string>; votes: Record<string, string[]> }>(), // Данные текущего раунда
        createdAt: timestamp('created_at').defaultNow().notNull(),
        updatedAt: timestamp('updated_at').defaultNow().notNull(),
        // ... другие поля по необходимости
    });

    export const users = pgTable('users', {
        id: uuid('id').defaultRandom().primaryKey(),
        nickname: text('nickname').notNull(),
        // ... другие поля для пользователей (если нужно будет хранить их)
    });

    API-эндпоинты (ElysiaJS):
        POST /game/create:
            Принимает: { nickname: string }.
            Создает новую запись в gameSessions с уникальным uuid.
            Возвращает: { gameId: string, gameUrl: string }.
            Важно: Первый игрок, который создает игру, автоматически становится первым в списке игроков.
        GET /game/:uuid/join: (Используется для начальной валидации, перед WS подключением)
            Принимает: { nickname: string } (если передается через тело запроса или query-параметр).
            Проверяет существование gameSession по uuid.
            Если игрок с таким ником уже есть в сессии, отклоняет или предлагает изменить ник.
            Возвращает: { success: boolean, message: string }.

3. WebSockets (ElysiaJS)

    Эндпоинт: ws /game/:uuid
    События WebSocket:
        connection:
            Игрок присоединяется к комнате по uuid.
            Бэкенд присваивает игроку уникальный playerId (может быть частью gameSession.players).
            Отправляет всем игрокам в комнате playerJoined событие с обновленным списком игроков.
            Важно: Определить порядок игроков при подключении.
        disconnect:
            Удаляет игрока из gameSession.players.
            Оповещает всех о playerLeft.
        leaderSelectsCardAndAssociation:
            Принимает: { cardId: string, association: string } от текущего ведущего.
            Валидация: Только ведущий может отправить это событие.
            Обновляет gameSession в БД.
            Отправляет всем игрокам associationChosen событие с association и обновленным состоянием игры.
        playerSubmitsCard:
            Принимает: { cardId: string } от не-ведущего игрока.
            Валидация: Игрок должен быть не-ведущим и ещё не выбрать карту.
            Сохраняет выбор игрока в gameSession.roundData.playerSelections.
            Если все игроки выбрали карты, бэкенд переходит к фазе голосования.
            Отправляет всем allCardsSubmitted событие с cardIds всех выбранных карт (перемешанных!).
        playerVotes:
            Принимает: { targetCardId: string } от игрока.
            Валидация: Игрок должен ещё не голосовать.
            Сохраняет голос в gameSession.roundData.votes.
            Если все проголосовали, бэкенд подсчитывает очки, обновляет gameSession.players (scores) и currentRound.
            Отправляет roundResults событие со всеми данными для отображения результатов.
            Определяет следующего ведущего.
            Отправляет newRoundStarted или gameOver событие.
        chatMessage:
            Принимает: { message: string }.
            Рассылает всем в комнате. (Для будущего)

4. Управление картами

    Предзагруженные карты (MVP):
        Храните статический список URL-адресов изображений карт на бэкенде или в отдельном файле (например, cards.json).
        При создании новой игры, бэкенд выбирает нужное количество карт из этого списка и добавляет их в gameSession.deck.
        Распределение карт игрокам происходит на бэкенде при начале каждого раунда.
    Хранение изображений: Изображения карт будут храниться в Azure Blob Storage, а в БД будут храниться только их URL.

5. Логика подсчета очков (MVP)

    Ведущий:
        Если все угадали его карту ИЛИ никто не угадал его карту, ведущий получает 0 очков.
        В противном случае (кто-то угадал, кто-то нет), ведущий получает 3 очка.
    Другие игроки:
        Получают 3 очка, если угадали карту ведущего.
        Получают 1 очко за каждого игрока, проголосовавшего за их карту (которая не является картой ведущего).

6. Стек технологий (Подтверждение)

    Фронтенд: SvelteKit (для SPA и удобства роутинга), Lucide-svelte (иконки), Bits-UI (headless UI), i18n (интернационализация), TailwindCSS (стилизация).
    Бэкенд: ElysiaJS, Drizzle-ORM.

